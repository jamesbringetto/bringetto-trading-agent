"""Base strategy class that all trading strategies inherit from."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from typing import Any
from uuid import UUID

from loguru import logger

from agent.config.constants import OrderSide, StrategyType
from agent.monitoring.instrumentation import get_instrumentation


@dataclass
class StrategySignal:
    """Signal generated by a strategy."""

    symbol: str
    side: OrderSide
    entry_price: Decimal
    stop_loss: Decimal
    take_profit: Decimal
    position_size_pct: float
    confidence: float
    reasoning: str
    indicators: dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.utcnow)

    @property
    def risk_reward_ratio(self) -> float:
        """Calculate risk/reward ratio."""
        if self.side == OrderSide.BUY:
            risk = float(self.entry_price - self.stop_loss)
            reward = float(self.take_profit - self.entry_price)
        else:
            risk = float(self.stop_loss - self.entry_price)
            reward = float(self.entry_price - self.take_profit)
        return reward / risk if risk > 0 else 0

    def to_dict(self) -> dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            "symbol": self.symbol,
            "side": self.side.value,
            "entry_price": str(self.entry_price),
            "stop_loss": str(self.stop_loss),
            "take_profit": str(self.take_profit),
            "position_size_pct": self.position_size_pct,
            "confidence": self.confidence,
            "reasoning": self.reasoning,
            "indicators": self.indicators,
            "timestamp": self.timestamp.isoformat(),
            "risk_reward_ratio": self.risk_reward_ratio,
        }


@dataclass
class MarketContext:
    """Current market context for strategy decisions."""

    symbol: str
    current_price: Decimal
    open_price: Decimal
    high_price: Decimal
    low_price: Decimal
    volume: int
    vwap: Decimal | None = None
    rsi: float | None = None
    macd: float | None = None
    macd_signal: float | None = None
    atr: float | None = None
    adx: float | None = None
    ma_50: Decimal | None = None
    ma_200: Decimal | None = None
    vix: float | None = None
    bid: Decimal | None = None
    ask: Decimal | None = None
    timestamp: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> dict[str, Any]:
        """Convert context to dictionary for logging."""
        return {
            "symbol": self.symbol,
            "current_price": str(self.current_price),
            "open_price": str(self.open_price),
            "high_price": str(self.high_price),
            "low_price": str(self.low_price),
            "volume": self.volume,
            "vwap": str(self.vwap) if self.vwap else None,
            "rsi": self.rsi,
            "macd": self.macd,
            "macd_signal": self.macd_signal,
            "atr": self.atr,
            "adx": self.adx,
            "vix": self.vix,
            "timestamp": self.timestamp.isoformat(),
        }


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    All strategies must implement:
    - should_enter(): Check if entry conditions are met
    - should_exit(): Check if exit conditions are met
    - calculate_position_size(): Determine position size
    """

    def __init__(
        self,
        strategy_id: UUID | None = None,
        name: str = "BaseStrategy",
        version: str = "1.0.0",
        strategy_type: StrategyType = StrategyType.EXPERIMENTAL,
        parameters: dict[str, Any] | None = None,
    ):
        self.strategy_id = strategy_id
        self.name = name
        self.version = version
        self.strategy_type = strategy_type
        self.parameters = parameters or {}
        self.is_active = True
        self._open_positions: dict[str, Any] = {}

        logger.info(
            f"Initialized strategy: {self.name} v{self.version} ({self.strategy_type.value})"
        )

    @abstractmethod
    def should_enter(self, context: MarketContext) -> StrategySignal | None:
        """
        Check if entry conditions are met for a trade.

        Args:
            context: Current market context with price and indicators

        Returns:
            StrategySignal if entry conditions met, None otherwise
        """
        pass

    @abstractmethod
    def should_exit(
        self, context: MarketContext, entry_price: Decimal, side: OrderSide
    ) -> tuple[bool, str]:
        """
        Check if exit conditions are met for an open position.

        Args:
            context: Current market context
            entry_price: Original entry price
            side: Original trade side (buy/sell)

        Returns:
            Tuple of (should_exit, reason)
        """
        pass

    @abstractmethod
    def calculate_position_size(
        self, context: MarketContext, account_value: Decimal
    ) -> Decimal:
        """
        Calculate the position size for a trade.

        Args:
            context: Current market context
            account_value: Current account value

        Returns:
            Position size in dollars
        """
        pass

    def calculate_stop_loss(
        self, entry_price: Decimal, side: OrderSide, atr: float | None = None
    ) -> Decimal:
        """
        Calculate stop loss price.

        Default implementation uses a percentage-based stop loss.
        Override for custom behavior.
        """
        stop_loss_pct = self.parameters.get("stop_loss_pct", 1.0) / 100
        if side == OrderSide.BUY:
            return entry_price * Decimal(1 - stop_loss_pct)
        else:
            return entry_price * Decimal(1 + stop_loss_pct)

    def calculate_take_profit(
        self, entry_price: Decimal, side: OrderSide, atr: float | None = None
    ) -> Decimal:
        """
        Calculate take profit price.

        Default implementation uses a percentage-based take profit.
        Override for custom behavior.
        """
        take_profit_pct = self.parameters.get("take_profit_pct", 2.0) / 100
        if side == OrderSide.BUY:
            return entry_price * Decimal(1 + take_profit_pct)
        else:
            return entry_price * Decimal(1 - take_profit_pct)

    def validate_entry(self, context: MarketContext) -> tuple[bool, str]:
        """
        Validate basic entry conditions before strategy-specific checks.

        Returns:
            Tuple of (is_valid, reason)
        """
        # Check if strategy is active
        if not self.is_active:
            return False, "Strategy is not active"

        # Check minimum price
        min_price = self.parameters.get("min_price", 5.0)
        if float(context.current_price) < min_price:
            return False, f"Price ${context.current_price} below minimum ${min_price}"

        # Check volume
        min_volume = self.parameters.get("min_volume", 1_000_000)
        if context.volume < min_volume:
            return False, f"Volume {context.volume} below minimum {min_volume}"

        # Check bid-ask spread if available
        if context.bid and context.ask:
            spread_pct = float((context.ask - context.bid) / context.current_price) * 100
            max_spread = self.parameters.get("max_spread_pct", 0.1)
            if spread_pct > max_spread:
                return False, f"Spread {spread_pct:.2f}% exceeds maximum {max_spread}%"

        return True, "Entry conditions valid"

    def get_open_positions_count(self) -> int:
        """Get count of open positions for this strategy."""
        return len(self._open_positions)

    def add_position(self, symbol: str, position_data: dict[str, Any]) -> None:
        """Track a new open position."""
        self._open_positions[symbol] = position_data

    def remove_position(self, symbol: str) -> None:
        """Remove a closed position from tracking."""
        self._open_positions.pop(symbol, None)

    def has_position(self, symbol: str) -> bool:
        """Check if strategy has an open position in a symbol."""
        return symbol in self._open_positions

    def disable(self, reason: str) -> None:
        """Disable the strategy with a reason."""
        self.is_active = False
        logger.warning(f"Strategy {self.name} disabled: {reason}")

    def enable(self) -> None:
        """Re-enable the strategy."""
        self.is_active = True
        logger.info(f"Strategy {self.name} enabled")

    def evaluate_entry(self, context: MarketContext) -> StrategySignal | None:
        """
        Evaluate entry conditions and record the decision via instrumentation.

        This is a wrapper around should_enter() that also logs the evaluation
        for observability purposes. Use this method in the main trading loop
        instead of calling should_enter() directly.

        Args:
            context: Current market context

        Returns:
            StrategySignal if entry conditions met, None otherwise
        """
        inst = get_instrumentation()

        # First validate basic conditions
        is_valid, rejection_reason = self.validate_entry(context)
        if not is_valid:
            inst.record_evaluation(
                strategy_name=self.name,
                symbol=context.symbol,
                evaluation_type="entry",
                decision="rejected",
                context={
                    "current_price": context.current_price,
                    "volume": context.volume,
                    "vwap": context.vwap,
                    "rsi": context.rsi,
                    "macd": context.macd,
                    "atr": context.atr,
                    "vix": context.vix,
                    "bid": context.bid,
                    "ask": context.ask,
                },
                rejection_reason=rejection_reason,
            )
            return None

        # Run strategy-specific evaluation
        signal = self.should_enter(context)

        if signal is None:
            inst.record_evaluation(
                strategy_name=self.name,
                symbol=context.symbol,
                evaluation_type="entry",
                decision="rejected",
                context={
                    "current_price": context.current_price,
                    "volume": context.volume,
                    "vwap": context.vwap,
                    "rsi": context.rsi,
                    "macd": context.macd,
                    "atr": context.atr,
                    "vix": context.vix,
                    "bid": context.bid,
                    "ask": context.ask,
                },
                rejection_reason="No signal generated",
            )
        else:
            inst.record_evaluation(
                strategy_name=self.name,
                symbol=context.symbol,
                evaluation_type="entry",
                decision="accepted",
                context={
                    "current_price": context.current_price,
                    "volume": context.volume,
                    "vwap": context.vwap,
                    "rsi": context.rsi,
                    "macd": context.macd,
                    "atr": context.atr,
                    "vix": context.vix,
                    "bid": context.bid,
                    "ask": context.ask,
                },
                signal={
                    "side": signal.side.value,
                    "confidence": signal.confidence,
                    "reasoning": signal.reasoning,
                    "entry_price": signal.entry_price,
                    "stop_loss": signal.stop_loss,
                    "take_profit": signal.take_profit,
                },
            )

        return signal

    def evaluate_exit(
        self, context: MarketContext, entry_price: Decimal, side: OrderSide
    ) -> tuple[bool, str]:
        """
        Evaluate exit conditions and record the decision via instrumentation.

        This is a wrapper around should_exit() that also logs the evaluation
        for observability purposes.

        Args:
            context: Current market context
            entry_price: Original entry price
            side: Original trade side

        Returns:
            Tuple of (should_exit, reason)
        """
        should_exit, reason = self.should_exit(context, entry_price, side)

        inst = get_instrumentation()
        inst.record_evaluation(
            strategy_name=self.name,
            symbol=context.symbol,
            evaluation_type="exit",
            decision="accepted" if should_exit else "rejected",
            context={
                "current_price": context.current_price,
                "volume": context.volume,
                "vwap": context.vwap,
                "rsi": context.rsi,
                "macd": context.macd,
                "atr": context.atr,
                "vix": context.vix,
                "bid": context.bid,
                "ask": context.ask,
            },
            rejection_reason=None if should_exit else reason,
            signal={"side": side.value, "reasoning": reason} if should_exit else None,
        )

        return should_exit, reason

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__}(name={self.name}, active={self.is_active})>"
